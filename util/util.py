import logging
from config import Config as cfg
import util.db as db
from util.Constants import Constants as cs
import pickle as pkl
import os
import matplotlib.pyplot as plt
import re
import numpy as np
import pandas as pd
import shutil

logging.basicConfig(format='%(levelname)s:%(message)s', level=cfg.logging_level)


def list_to_dict(card_list):
    card_dict = {}

    for card in card_list:

        if card not in card_dict:
            card_dict[card] = 1
        else:
            card_dict[card] += 1

    return card_dict


def print_divider():
    logging.debug(cs.DIVIDER)


def generate_run_id():
    if cfg.run_id == 'TEST':
        return cfg.run_id + '_' + str(db.get_global_max_id())
    else:
        return cfg.run_id


def get_pretty_time(duration, num_digits=2):
    # Duration is assumed to be in seconds. Returns a string with the appropriate suffix (s/m/h)
    if duration > 60**2:
        return str(round(duration / 60**2, num_digits)) + 'h'
    if duration > 60:
        return str(round(duration / 60, num_digits)) + 'm'
    else:
        return str(round(duration, num_digits)) + 's'


def save_config(config, path=None):
    path = 'latest' if path is None else path
    os.makedirs('saved_configs', exist_ok=True)
    with open(os.path.join(cfg.config_folder, path + '.pkl'), 'wb') as f:
        pkl.dump(config, f)


def get_config(path=None):
    path = 'latest' if path is None else path
    with open(os.path.join(cfg.config_folder, path + '.pkl'), 'rb') as f:
        config = pkl.load(f)
    return config


def setup_file_logger(name, filename='run_log', level=cfg.logging_level):
    log_setup = logging.getLogger(name)

    os.makedirs(cfg.log_folder, exist_ok=True)

    fileHandler = logging.FileHandler(os.path.join(cfg.log_folder, filename + '.log'), mode='a')
    formatter = logging.Formatter('%(levelname)s: %(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
    fileHandler.setFormatter(formatter)

    # consoleHandler = logging.StreamHandler()
    # consoleHandler.setFormatter(formatter)

    log_setup.setLevel(level)
    log_setup.addHandler(fileHandler)
    # log_setup.addHandler(consoleHandler)


def convert_np_hist_to_plot(np_hist):
    """
    Converts a numpy representation of a histogram into a matplotlib.pyplot object
    :param np_hist: tuple generated by np.histogram(vec)
    :return: Returns a matplotlib.pyplot bar plot object
    """
    height, bins = np_hist
    width = (bins.max() - bins.min())/(len(bins) - 1)
    return plt.bar(height=height, x=bins[:-1], width=width)


def get_checkpoint_model_name(cycle):
    # Returns a formatted string for the title of a checkpointed model
    return f'cycle_{cycle}_checkpoint'


def get_max_checkpoint_cycle(run_id):
    # Returns the current maximum cycle value for all checkpointed models of a specific run id
    path = os.path.join(cfg.checkpoint_folder, run_id)
    checkpoints = [int(re.search('\d+', cp)[0]) for cp in os.listdir(path)]
    return np.max(checkpoints)


def get_model_checkpoint(run_id, cycle=-1):
    # cycle of -1 (default) implies the user wants the largest checkpoint value available
    if cycle == -1:
        cycle = get_max_checkpoint_cycle(run_id=run_id)

    path = os.path.join(cfg.checkpoint_folder, run_id, get_checkpoint_model_name(cycle=cycle) + '.pkl')
    with open(path, 'rb') as f:
        return pkl.load(f)


def get_trick_reward(trick_score, player, winner):
    # Returns reward for player based on trick score and trick winner
    # Positive if winner, negative if loser.
    return trick_score * -1 if player != winner else trick_score


def get_experiment_file(file):
    return pd.read_csv(os.path.join(cfg.experiment_folder, file), dtype={'episodes_per_cycle': int})


def overwrite_cfg(exp, config):
    config.logging_level = logging.INFO
    for key, value in exp.items():
        if not pd.isna(value):
            if key in dir(config):
                setattr(config, key, value)
            elif key in config.DQN_params:
                config.DQN_params[key] = value
            elif key in config.GH_params:
                config.GH_params[key] = value
            else:
                raise Exception(f'Bad column title in file: {key}')
    return config


def clear_run(run_id):
    """Clears all saved information about a specified run_id"""
    # Logs
    log_path = os.path.join(cfg.log_folder, run_id + '.log')
    if os.path.exists(log_path):
        os.remove(log_path)
        print(f'Logs for {run_id} cleared.')

    # Model Checkpoints
    model_checkpoint_path = os.path.join(cfg.checkpoint_folder, run_id)
    if os.path.exists(model_checkpoint_path):
        shutil.rmtree(model_checkpoint_path)
        print(f'Model checkpoints for {run_id} cleared.')

    # Saved models
    saved_model_path = os.path.join(cfg.final_models_folder, run_id + '.pkl')
    if os.path.exists(saved_model_path):
        os.remove(saved_model_path)
        print(f'Saved model for {run_id} cleared.')

    # Saved configs
    saved_config_path = os.path.join(cfg.config_folder, run_id + '.pkl')
    if os.path.exists(saved_config_path):
        os.remove(saved_config_path)
        print(f'Config for {run_id} cleared.')

    # DB entries
    db.clear_run(run_id=run_id)
    print(f'DB entries for {run_id} cleared (if they existed).')


def get_reward(player, state_1, state_2, winner=None):
    """
    Reward is calculated as follows:
        1. Score component: Change in net advantage between states
        2. Game Over component: If game is over, +50 if win and -50 if lose

    :param player: Player object for which to calculate reward
    :param state_1: Initial state
    :param state_2: Next state
    :param winner: If None, game is not over. If not None, specifies the player object who won the entire game
    :return: Reward
    """

    score_component = state_2.get_player_state(player)[24] - state_1.get_player_state(player)[24]  # Score differential is 24th index (immediately after hand)
    game_component = 0

    if winner is not None:
        if player == winner:
            game_component = 50
        else:  # Lose
            game_component = -50

    return score_component + game_component
